<html lang="en">

<head>
    <meta name="viewport" content="width=1024" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Opinionated Screed on Unit Testing</title>
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" />
    <link href="css/screed.css" rel="stylesheet" />
    <link rel="shortcut icon" href="images/yin_yang_ico.png" />
</head>

<body class="impress-not-supported">
    <div id="impress">

        <div id="start" class="step slide" data-x="-1000" data-y="-1500" data-scale="1">
          <h1>Opinionated Screed On Unit Testing</h1>
          <h1>&nbsp;</h1>
          <h1>Scott Overholser</h1>
          <h1>http://github.com/eigenholser</h1>
          <h1>@eigenholser</h1>
          <!--
          * Introduction. Medici Ventures, blockchain.
          * Explain how this talk came to be. Many differing opinions. Poorly
            written and organized tests.
          * Developers have a love/hate relationship with tests.
          * Focus on unit testing but will touch on integration testing from
            time to time.
          -->
        </div>

        <div id="opinionated" class="step defn" data-x="800" data-y="250" data-rotate="90" data-scale="5">
          <p><b class="rotating">o·pin·ion·at·ed</b> /əˈpinyəˌnādəd/ <em>adjective</em></p>
          <p>conceitedly assertive and dogmatic in one's opinions.</p>
          <!--
          * One of the benefits of giving a talk on a subject is how much we learn.
          * Intended as humour.
          -->
        </div>

        <div id="screed" class="step defn" data-x="-800" data-y="1400" data-rotate="90" data-rotate-x="30" data-rotate-y="30" data-scale="5">
          <p><b class="rotating">screed</b> /skrēd/ <em>noun</em></p>
          <p>a long speech or piece of writing, typically one regarded as tedious.</p>
          <!--
          * Your mileage may vary.
          -->
        </div>

<!-- hate unit tests -->
        <div id="broken" class="step center" data-x="3700" data-y="-900" data-z="0" data-scale="4">
          <p>I<img src="images/heart-broken.png" width="250"/><br/>UT</p>
          <!--
          * Developers seem to hate unit tests.
          * Afterthought. Don't leave time for testing.
          * Often stale.
          -->
        </div>

<!-- What is a unit test? -->
        <div id="notint" class="step center" data-x="6600" data-y="200" data-rotate="90" data-scale="5">
          <p><b class="unittests">unit tests</b> are <b class="not">not</b><br/><span class="integration">integration<br/>tests</span></p>
          <!--
          * Wife asked "what does a unit test do..."
          * Two distinct kinds of tests.
            - Unit tests
            - Integration tests, also often called system or functional tests.
              these are full stack tests.
          * Unit tests test our own units of code, hopefully isolated.
          * Integration tests test the full stack winding it's way through all
            of our code paths.
          * Integration tests are often fragile.
          -->
        </div>

        <!-- Not a unit test if...-->
        <div id="notif-title" class="step left" data-x="3100" data-y="1200" data-z="0" data-rotate="180" data-scale="6">
          <p>A test is <b class="rotating">not</b><br/>a <b>unit test</b> if...</p>
        </div>
        <div id="database" class="step left" data-x="5100" data-y="-900" data-z="-3000" data-rotate="0" data-scale="2">
            <p>It talks to the database</p>
        </div>
        <div id="network" class="step left" data-x="4700" data-y="100" data-z="-3000" data-rotate="45" data-scale="2">
            <p>It communicates across<br/> the network.</p>
        </div>
        <div id="filesystem" class="step left" data-x="3800" data-y="600" data-z="-3000" data-rotate="90" data-scale="2">
            <p>It touches the filesystem</p>
        </div>
        <div id="same-time" class="step left" data-x="2800" data-y="200" data-z="-3000" data-rotate="135" data-scale="2">
            <p>It can't run at the same time as any of your other unit tests</p>
        </div>
        <div id="special" class="step left" data-x="2400" data-y="-900" data-z="-3000" data-rotate="180" data-scale="2">
          <p>You have to do special things to your<br/>
          environment (such as editing config files) to run it.</p>
        </div>

<!-- Unit tests should... -->
        <div id="fast" class="step center" data-x="400" data-y="3300" data-rotate="180" data-scale="6">
          <p>Unit tests <b>should</b> be<br/><em class="positioning">...FAST!</em></p>
          <!--
          * Waiting 30 minutes for tests to run is 30 minutes of your life you'll
            never get back.
          * It means you will avoid running the tests.
          -->
        </div>
        <div id="separate" class="step center" data-x="1300" data-y="3100" data-z="-1000" data-rotate="90" data-scale="1">
          <p>Unit tests <b>should</b> be separate</p>
          <!--
          * Unit tests and integration tests should be separate.
          * They serve different purposes. Mingling them makes it impossible to
            run them separately.
          * Integration tests require external dependencies that are difficult
            to implement on a developer environment.
          * During development, devs should be running unit tests often. Separation
            of unit and integration tests reduces friction.
          -->
        </div>
        <div id="assert-one" class="step left" data-x="200" data-y="3800" data-z="-1000" data-rotate="180" data-scale="1">
          <p>Unit tests <b>should</b> assert only one thing</p>
          <!--
          * Unit tests should be simple. Multiple assertions make it more difficult
            to understand what failed.
          * The exception is when multiple assertions are used to confirm results
            that are related.
          -->
        </div>
        <div id="often" class="step center" data-x="-800" data-y="3100" data-z="-1000" data-rotate="270" data-scale="1">
          <p>Unit tests <b>should</b> be run often</p>
          <!--
          * Before modifying code
          * After code change
          * At night before you leave
          * In the morning when you arrive
          * Just because
          -->
        </div>

<!-- Tips -->
        <div id="tips" class="step center" data-x="6500" data-y="3700" data-scale="3">
          <p><b>Tips</b></p>
          <!--
          * Adopting some best practices can make unit tests more useful.
          -->
        </div>
        <div id="naming" class="step center" data-x="6000" data-y="3500" data-z="-10000" data-scale="1">
          <p>Naming</p>
          <!--
          * Two hardest things in computer science...
          * Unit tests names should act as a specification.
          * Describe what is expected.
          * Helps locate the problem on failed test.
          -->
        </div>
        <div id="comment" class="step center" data-x="6200" data-y="3800" data-z="-10000" data-scale="1">
          <p><span class="comment">comment</span><br/>your tests</p>
        </div>
        <div id="isolate" class="step center" data-x="6700" data-y="3700" data-z="-10000" data-rotate="90" data-scale="1">
          <p><span class="isolate">Isolate</span></p>
          <!--
          * Mocks, stubs, test doubles
          * Loose coupling helps with this.
          -->
        </div>
        <div id="overspecification" class="step center" data-x="7000" data-y="4000" data-z="-10000" data-rotate="270" data-scale="1">
          <p>Overspecification</p>
          <!--
          * Leads to tests coupling strongly to production code and limiting
            ability to refactor.
          * Sign of this is testing implementation details instead of the
            overall behavior.
          * Overusing mocks is an indicator of overspecification.
          * Prefer stubs over mocks as much as possible.
          * Test should focus on testing the results of a function instead of
            the internal actions. Not always possible. Refer to design.
          -->
        </div>
        <div id="brevity" class="step center" data-x="6200" data-y="4100" data-z="-10000" data-scale="1">
          <p>Brevity</p>
          <!--
          * Tests should be short and to the point.
          * Long elaborate tests indicate overspecification or the code is in
            need of refactoring.
          * Brevity helps us maintain focus on tests as documentation.
          -->
        </div>
        <div id="setup" class="step center" data-x="7500" data-y="4200" data-z="-10000" data-scale="1">
          <p><b class="setup">Setup</b><br/><span class="and">and</span><br/><b class="teardown">Teardown</b></p>
          <!--
          * Setup common dependencies for each suite of tests.
          * Teardown resets dependencies.
          * Prevents fragile unit tests by breaking dependencies between tests.
          -->
        </div>
        <div id="ara" class="step center" data-x="6200" data-y="5000" data-z="-10000" data-rotate="360" data-scale="1">
          <p>Arrange<br/>Act<br/>Assert</p>
          <!--
          * Perform any setup that needs to be done.
          * Call the unit.
          * Assert to confirm the single result, even if multiple asserts are
            needed for this purpose.
          -->
        </div>
        <div id="damp" class="step center xyz" data-x="6800" data-y="4600" data-z="-10000" data-scale="1">
          <p><span class="damp">DAMP</span><br/><b class="vs">vs</b><br/><span class="dry">DRY</span></p>
          <!--
          * Don't Repeat Yourself
          * Declarative And Meaningful Phrases
          * Each test is an isolated chapter in your test book. If removing a
            piece of logic hurts the readability, then don't remove it.
          * From a maintenance perspective, don't centralize a piece of logic
            that can't be changed on it's own.
          -->
        </div>
        <div id="perfection" class="step center" data-x="6200" data-y="4500" data-z="-10000" data-scale="1">
          <p><span class="perf-avoid">avoid</span><br/>perfection</p>
          <!--
          * Remember, you're trying to run a business!
          * Perfection takes a lot of time. Don't waste time.
          * The test can be refactored if it fails when it shouldn't.
          * Insufficient isolation can be fixed later if necessary.
          -->
        </div>
        <div id="coverage" class="step center" data-x="7400" data-y="4800" data-z="-10000" data-rotate="90" data-scale="1">
          <p>Code<br/>Coverage</p>
          <!--
          * Some devs don't like code coverage reports.
          * How do you know what you're really testing?
          * Code coverage reports help reason about design and guide refactor.
          * Spot trends in testing coverage over time.
          * Test quality != code coverage.
          -->
        </div>
        <div id="tdd" class="step center" data-x="5700" data-y="4700" data-z="-10000" data-rotate="90" data-scale="1">
          <!-- <p>Test<br/>Driven<br/>Development</p> -->
          <p>TDD</p>
          <!--
          * Does not mean Test Deficit Disorder.
          * Test last: Risks, design problems and bugs discovered late. Can
            descend into frustrating spiral of debugging and rework.
          * Test last leads to heavy refactoring burdens.
          * You might not leave time for adequate test design, leading to being
            rushed. May miss important cases.
          * Test first? I haven't even figured out what to name stuff yet...
          * Test first forces you to specify what you are building in advance
            of building it.
          * Risk of rework. Mini waterfall. Discoveries during development that
            make you want to iterate.
          * Test driven development. Designing tests and code together.
          * Allow the design of the tests and the code emerge as you develop.
          * TDD, ahhh, nirvana. Iterative cycle. Helps guide to clear design.
          * Poorly designed code is hard to test.
          * If writing unit tests is hard, your code is probably poorly designed.
          -->
        </div>
        <div id="limitations" class="step center" data-x="6200" data-y="4800" data-z="-14000" data-rotate="0" data-scale="3">
          <p>Limitations</p>
          <!--
          * Unit tests will not prove correctness. GIGO.
          * Unit testing won't find integration errors.
          * Non-functional requirements like performance and security.
          -->
        </div>

<!-- Purpose -->
        <div id="why" class="step left" data-x="6200" data-y="2500" data-rotate="-15" data-scale="5">
          <p>All this <b class="positioning">time</b> and<br/>
            <b class="rotating">effort</b> spent writing<br/>
             tests. Why do we do<br/>
             it...?</p>
          <!--
          * Your own personal development process.
          * Developer responsibility. Not optional extra or job of seperate test team.
          * Avoid embarrassing bugs in your code that others find.
          * To help your team not break your code
          * Writing code is how you tell your colleagues how you feel about them.
          * Psychopathic developer who knows where you live.
          -->
        </div>
        <div id="what" class="step center" data-x="5600" data-y="4400" data-z="-44000" data-rotate="90" data-scale="3">
          <p><span class="understand">Understand</span><br/><b class="what">what</b><br/><span class="build">to build</span></p>
          <!--
          * Unit tests cannot be written without a good understanding of what
            to build. Forces business requirements.
          -->
        </div>
        <div id="design" class="step center" data-x="7200" data-y="5000" data-z="-44000" data-rotate="180" data-scale="3">
          <p>Better<br/>Design</p>
          <!--
          * Anecdote about PDF Form Filler being untestable.
          * Well designed code is testable. If your code is hard to test, it is
            not well designed.
          * Decompose the problem into units that are independently testable.
            (loose coupling)
          * Forces thinking of interface seperately from implementation.
          * Just the discipline of writing unit tests helps with better design.
          -->
        </div>
        <div id="documentation" class="step center" data-x="5800" data-y="6000" data-z="-44000" data-rotate="0" data-scale="3">
          <p>Documentation</p>
          <!--
          * Unit tests document our units. Comments help with this.
          * Unit tests should be highly readable.
          * Think of them as an executable specification. Tests document the
            behavior of the code in a form you can execute.
          * Demonstrates how a unit is intended to be used, how to construct
            it, call the method, what kind of arguments, what kind of results.
          -->
        </div>
        <div id="fear" class="step center" data-x="8000" data-y="6400" data-z="-44000" data-scale="3">
          <p>Fear free<br/>refactor<br/>...mostly</p>
          <!--
          * Adding new functionality or just refactoring units is easier. Unit
            tests let us know quickly when something is broken.
          -->
        </div>
        <div id="regression" class="step center" data-x="7800" data-y="3500" data-z="-42000" data-rotate="360" data-scale="3">
          <p>Regression<br/>protection</p>
          <!--
          * Something that worked before and now doesn't.
          * Changes to unknown dependencies can cause failures.
          * Test failure messages should be very clear and readable so it is
            easy to find any failures.
          -->
        </div>

          <!--

          Omitting this slide since it is more about integration testing.

        <div id="ci" class="step center" data-x="10600" data-y="6400" data-z="-14000" data-rotate="90" data-scale="3">
          <p>continuous<br/>integration</p>
          * Continuous integration environment catches integration errors that
            unit tests alone do not catch.
          * Unit tests provide an objective go, no-go assessment for deployment.
          * Note that this should include integration tests as well.
        </div>
          -->

<!-- love -->
        <div id="love" class="step center" data-x="2800" data-y="3500" data-z="0" data-rotate="180" data-scale="4">
          <p>I<img src="images/heart.png" height="250"/><br/>UT</p>
          <!--
          A top 10?
          * Unit tests are your friend. They make your life easier.
          * Unit tests make you a better developer.
          * They are challenging and fun!
          * Unit tests earn the admiration of your colleagues.
          * I love unit tests!
          -->
        </div>

        <div id="overview" class="step" data-x="3000" data-y="1500" data-scale="10">
        </div>
    </div>
    <div class="fallback-message">
        <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
        <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
    </div>
    <script type="text/javascript" src="js/impress.js"></script>
    <script type="text/javascript">
        impress().init();
    </script>
</body>

</html>
